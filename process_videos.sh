#!/bin/bash

# SoundSplitter Video Post-Processing Script
# This script processes video files generated by SoundSplitter:
# 1. Converts .mov files to .mp4 using FFmpeg with H.265 compression and dynamic audio normalization
# 2. Joins multiple segments per person with fade transitions using FFmpeg
# 3. Re-compresses joined files only if needed (usually skipped due to optimal encoding)

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly BITRATE="1500"  # Video bitrate in kbps

# Dynamic audio normalization settings for quiet phone recordings
# p=0.95: Peak percentile (95th percentile for peak detection)
# m=10: Minimum frames to analyze for each segment  
# s=12: Target window size in frames for analysis
# g=25: Maximum gain factor in dB
readonly DYNAUDNORM_SETTINGS="dynaudnorm=p=0.95:m=10:s=12:g=25"

# Find the extracted directory - look in current dir first, then subdirectories
find_extracted_directory() {
    local extracted_dir=""
    
    # Check current directory first
    if [[ -d "${SCRIPT_DIR}/extracted" ]]; then
        extracted_dir="${SCRIPT_DIR}/extracted"
    else
        # Search for extracted directory in subdirectories
        local found_dirs
        found_dirs=$(find "${SCRIPT_DIR}" -type d -name "extracted" -maxdepth 3 2>/dev/null | head -1)
        if [[ -n "$found_dirs" ]]; then
            extracted_dir="$found_dirs"
        fi
    fi
    
    echo "$extracted_dir"
}

readonly EXTRACTED_DIR="$(find_extracted_directory)"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Progress tracking variables
PROGRESS_START_TIME=0
PROGRESS_CURRENT=0
PROGRESS_TOTAL=0
PROGRESS_FILE_TIMES=()

# Initialize progress tracking
init_progress() {
    local total="$1"
    PROGRESS_START_TIME=$(date +%s)
    PROGRESS_CURRENT=0
    PROGRESS_TOTAL="$total"
    PROGRESS_FILE_TIMES=()
}

# Update progress and show progress bar with ETA
update_progress() {
    local current="$1"
    local current_file="${2:-}"
    local file_start_time="${3:-}"
    
    PROGRESS_CURRENT="$current"
    
    # Calculate overall progress percentage
    local percent=0
    if [[ $PROGRESS_TOTAL -gt 0 ]]; then
        percent=$(( (current * 100) / PROGRESS_TOTAL ))
    fi
    
    # Calculate time statistics
    local current_time=$(date +%s)
    local elapsed_total=$((current_time - PROGRESS_START_TIME))
    
    # Store file processing time if provided
    if [[ -n "$file_start_time" && $file_start_time -gt 0 ]]; then
        local file_time=$((current_time - file_start_time))
        PROGRESS_FILE_TIMES+=("$file_time")
    fi
    
    # Calculate ETA based on average processing time
    local eta_seconds=0
    local remaining_files=$((PROGRESS_TOTAL - current))
    
    if [[ $current -gt 0 && $remaining_files -gt 0 ]]; then
        local avg_time_per_file=$((elapsed_total / current))
        eta_seconds=$((avg_time_per_file * remaining_files))
    fi
    
    # Format ETA
    local eta_formatted
    if [[ $eta_seconds -gt 3600 ]]; then
        eta_formatted=$(printf "%dh %02dm %02ds" $((eta_seconds/3600)) $(((eta_seconds%3600)/60)) $((eta_seconds%60)))
    elif [[ $eta_seconds -gt 60 ]]; then
        eta_formatted=$(printf "%02dm %02ds" $((eta_seconds/60)) $((eta_seconds%60)))
    else
        eta_formatted="${eta_seconds}s"
    fi
    
    # Create progress bar (50 characters wide)
    local bar_length=50
    local filled_length=$(( (percent * bar_length) / 100 ))
    local bar=""
    
    for ((i=0; i<filled_length; i++)); do
        bar+="█"
    done
    for ((i=filled_length; i<bar_length; i++)); do
        bar+="░"
    done
    
    # Format elapsed time
    local elapsed_formatted
    if [[ $elapsed_total -gt 3600 ]]; then
        elapsed_formatted=$(printf "%dh %02dm %02ds" $((elapsed_total/3600)) $(((elapsed_total%3600)/60)) $((elapsed_total%60)))
    elif [[ $elapsed_total -gt 60 ]]; then
        elapsed_formatted=$(printf "%02dm %02ds" $((elapsed_total/60)) $((elapsed_total%60)))
    else
        elapsed_formatted="${elapsed_total}s"
    fi
    
    # Clear the line and print progress bar
    printf "\r\033[K"
    if [[ $remaining_files -eq 0 ]]; then
        printf "${GREEN}[COMPLETE]${NC} [%s] %d/%d files (100%%) - Total time: %s" \
            "$bar" "$current" "$PROGRESS_TOTAL" "$elapsed_formatted"
    else
        printf "${BLUE}[PROGRESS]${NC} [%s] %d/%d files (%d%%) - ETA: %s" \
            "$bar" "$current" "$PROGRESS_TOTAL" "$percent" "$eta_formatted"
    fi
    
    # Show current file if provided
    if [[ -n "$current_file" ]]; then
        printf "\n${YELLOW}Current:${NC} %s" "$(safe_basename "$current_file")"
    fi
    
    # Move to next line if complete, otherwise stay on same line for updates
    if [[ $remaining_files -eq 0 ]]; then
        printf "\n"
    fi
}

# Show progress for current file being processed (called during HandBrake execution)
show_file_progress() {
    local current_file="$1"
    printf "\n${YELLOW}Processing:${NC} %s\n" "$(safe_basename "$current_file")"
}

# Check if required tools are available
check_dependencies() {
    log_info "Checking dependencies..."
    
    local missing_deps=()
    
    if ! command -v ffmpeg &> /dev/null; then
        missing_deps+=("ffmpeg")
    fi
    
    if ! command -v ffprobe &> /dev/null; then
        missing_deps+=("ffprobe")
    fi
    
    # Note: HandBrake and editron functionality now integrated with FFmpeg
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing_deps[*]}"
        log_error "Please install missing dependencies:"
        log_error "  ffmpeg: brew install ffmpeg"
        exit 1
    fi
    
    log_success "All dependencies found"
}

# Check if extracted directory exists and has files
check_extracted_directory() {
    if [[ -z "${EXTRACTED_DIR}" || ! -d "${EXTRACTED_DIR}" ]]; then
        log_error "Extracted directory not found in ${SCRIPT_DIR} or its subdirectories"
        log_error "Please run SoundSplitter first to generate video segments"
        log_error "Looking for: extracted/ directory containing .mov files"
        exit 1
    fi
    
    log_info "Found extracted directory: ${EXTRACTED_DIR}"
    
    local mov_count mp4_count
    mov_count=$(find "${EXTRACTED_DIR}" -name "*.mov" -type f | wc -l)
    mp4_count=$(find "${EXTRACTED_DIR}" -name "*.mp4" -type f ! -name "*-output.mp4" | wc -l)
    
    if [[ ${mov_count} -eq 0 && ${mp4_count} -eq 0 ]]; then
        log_error "No video files found in ${EXTRACTED_DIR}"
        log_error "Please run SoundSplitter first to generate video segments"
        exit 1
    fi
    
    if [[ ${mov_count} -gt 0 ]]; then
        log_info "Found ${mov_count} .mov files to process"
    fi
    
    if [[ ${mp4_count} -gt 0 ]]; then
        log_info "Found ${mp4_count} .mp4 files already processed"
    fi
}

# Safe filename handling - escape special characters for shell commands
escape_for_shell() {
    local filename="$1"
    # Use printf %q for robust shell escaping that works across all shells
    printf '%q' "$filename"
}

# Safe basename that handles special characters
safe_basename() {
    local filepath="$1"
    local extension="${2:-}"
    
    if [[ -n "$extension" ]]; then
        basename "$filepath" "$extension"
    else
        basename "$filepath"
    fi
}

# Validate if file is a valid video file
validate_video_file() {
    local file="$1"
    local basename_file
    basename_file=$(safe_basename "$file")
    
    # Check if file exists and has size
    if [[ ! -f "$file" ]]; then
        log_error "File not found: ${basename_file}"
        return 1
    fi
    
    local file_size
    file_size=$(stat -f%z "$file" 2>/dev/null || echo "0")
    if [[ ${file_size} -eq 0 ]]; then
        log_error "File is empty: ${basename_file}"
        return 1
    fi
    
    # Use ffprobe to validate video file
    if ! ffprobe -v quiet -select_streams v:0 -show_entries stream=codec_name -of csv=p=0 "$file" >/dev/null 2>&1; then
        log_error "Invalid or corrupted video file: ${basename_file}"
        return 1
    fi
    
    return 0
}

# Convert a single MOV file to MP4 using FFmpeg with dynamic audio normalization
convert_mov_to_mp4() {
    local input_file="$1"
    local output_file="$2"
    
    # Get safe display names
    local input_basename
    input_basename=$(safe_basename "$input_file")
    
    # Validate input file first
    if ! validate_video_file "$input_file"; then
        return 1
    fi
    
    # Use FFmpeg with QuickTime-compatible H.265 encoding and dynamic audio normalization
    local ffmpeg_cmd=(
        ffmpeg -y -hwaccel videotoolbox
        -i "$input_file"
        -c:v hevc_videotoolbox
        -profile:v main10 -level 4.1
        -pix_fmt yuv420p10le
        -b:v "${BITRATE}k" -maxrate "${BITRATE}k" -bufsize "$((BITRATE * 2))k"
        -tag:v hvc1
        -movflags +faststart
        -af "$DYNAUDNORM_SETTINGS"
        -c:a aac -b:a 163k
        "$output_file"
    )
    
    # Run FFmpeg with progress output redirected
    if ! "${ffmpeg_cmd[@]}" >/dev/null 2>&1; then
        printf "\n${RED}[ERROR]${NC} Failed to convert ${input_basename}\n"
        return 1
    fi
    
    # Verify output file was created and has reasonable size
    if [[ ! -f "$output_file" ]]; then
        log_error "Output file $(safe_basename "$output_file") was not created"
        return 1
    fi
    
    local input_size output_size
    input_size=$(stat -f%z "$input_file" 2>/dev/null || echo "0")
    output_size=$(stat -f%z "$output_file" 2>/dev/null || echo "0")
    
    if [[ ${output_size} -eq 0 ]]; then
        log_error "Output file $(safe_basename "$output_file") is empty"
        return 1
    fi
    
    local compression_ratio
    if [[ ${input_size} -gt 0 ]]; then
        compression_ratio=$(( (output_size * 100) / input_size ))
        printf "\n${GREEN}[SUCCESS]${NC} Converted ${input_basename} (${compression_ratio}%% of original size)\n"
    else
        printf "\n${GREEN}[SUCCESS]${NC} Converted ${input_basename}\n"
    fi
    
    return 0
}

# Step 1: Convert all MOV files to MP4
convert_all_mov_files() {
    log_info "=== Step 1: Converting MOV files to MP4 ==="
    
    local mov_files=()
    local failed_conversions=()
    
    # Find all MOV files
    while IFS= read -r -d '' file; do
        mov_files+=("$file")
    done < <(find "${EXTRACTED_DIR}" -name "*.mov" -type f -print0)
    
    if [[ ${#mov_files[@]} -eq 0 ]]; then
        log_warning "No MOV files found to convert"
        return 0
    fi
    
    # Initialize progress tracking
    init_progress ${#mov_files[@]}
    local completed_count=0
    
    # Convert each MOV file
    for mov_file in "${mov_files[@]}"; do
        local basename_no_ext
        basename_no_ext=$(safe_basename "$mov_file" .mov)
        local mp4_file="${EXTRACTED_DIR}/${basename_no_ext}.mp4"
        
        # Skip if MP4 already exists and is newer than MOV
        if [[ -f "$mp4_file" && "$mp4_file" -nt "$mov_file" ]]; then
            ((completed_count++))
            update_progress "$completed_count"
            printf "\n${BLUE}[INFO]${NC} Skipping $(safe_basename "$mov_file") - MP4 already exists and is newer\n"
            continue
        fi
        
        # Record start time for this file
        local file_start_time=$(date +%s)
        update_progress "$completed_count" "$mov_file"
        show_file_progress "$mov_file"
        
        if convert_mov_to_mp4 "$mov_file" "$mp4_file"; then
            # Remove original MOV file to save space
            rm "$mov_file"
            ((completed_count++))
            update_progress "$completed_count" "" "$file_start_time"
            printf "\n${BLUE}[INFO]${NC} Removed original $(safe_basename "$mov_file")\n"
        else
            ((completed_count++))
            update_progress "$completed_count" "" "$file_start_time"
            failed_conversions+=("$(safe_basename "$mov_file")")
        fi
    done
    
    # Ensure we end with a clean line after progress bar
    printf "\n"
    
    if [[ ${#failed_conversions[@]} -gt 0 ]]; then
        log_error "Failed to convert: ${failed_conversions[*]}"
        exit 1
    fi
    
    log_success "All MOV files converted to MP4"
}

# Analyze files to categorize single vs multiple presenters
analyze_presenters() {
    log_info "=== Analyzing presenter files ==="
    
    # Create associative array for presenter counts (compatible with older bash)
    local presenter_counts_file="${EXTRACTED_DIR}/.presenter_counts"
    > "$presenter_counts_file"  # Clear the file
    
    local mp4_files=()
    
    # Find all MP4 files
    while IFS= read -r -d '' file; do
        mp4_files+=("$file")
    done < <(find "${EXTRACTED_DIR}" -name "*.mp4" -type f ! -name "*-output.mp4" -print0)
    
    # Count files per presenter
    for file in "${mp4_files[@]}"; do
        local basename_file
        basename_file=$(basename "$file" .mp4)
        
        # Extract presenter name (everything before the last dash and number)
        local presenter_name
        if [[ $basename_file =~ ^(.+)-[0-9]+$ ]]; then
            presenter_name="${BASH_REMATCH[1]}"
            echo "$presenter_name" >> "$presenter_counts_file"
        else
            log_warning "Unrecognized file pattern: $basename_file"
        fi
    done
    
    # Categorize presenters
    local single_presenters=()
    local multiple_presenters=()
    
    # Get unique presenters and their counts
    if [[ -f "$presenter_counts_file" ]]; then
        local unique_presenters
        unique_presenters=$(sort "$presenter_counts_file" | uniq)
        
        while IFS= read -r presenter; do
            [[ -z "$presenter" ]] && continue
            local count
            count=$(grep -c "^${presenter}$" "$presenter_counts_file")
            if [[ $count -eq 1 ]]; then
                single_presenters+=("$presenter")
            else
                multiple_presenters+=("$presenter")
            fi
        done <<< "$unique_presenters"
    fi
    
    log_info "Single segment presenters (${#single_presenters[@]}): ${single_presenters[*]}"
    log_info "Multiple segment presenters (${#multiple_presenters[@]}): ${multiple_presenters[*]}"
    
    # Export for use in other functions
    printf '%s\0' "${single_presenters[@]}" > "${EXTRACTED_DIR}/.single_presenters"
    printf '%s\0' "${multiple_presenters[@]}" > "${EXTRACTED_DIR}/.multiple_presenters"
    
    # Clean up temporary file
    rm -f "$presenter_counts_file"
}

# Get video duration using ffprobe
get_video_duration() {
    local file="$1"
    ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$file" 2>/dev/null
}

# Join multiple MP4 files with fade transitions (integrated from editron)
join_video_files_with_fades() {
    local presenter="$1"
    local output_file="$2"
    
    # Find all input files for this presenter
    local input_files=()
    for i in {1..50}; do  # Check up to 50 segments
        local segment_file="${EXTRACTED_DIR}/${presenter}-${i}.mp4"
        if [[ -f "$segment_file" ]]; then
            input_files+=("$segment_file")
        fi
    done
    
    if [[ ${#input_files[@]} -lt 2 ]]; then
        log_error "Need at least 2 input files to join for $presenter"
        return 1
    fi
    
    # Sort files numerically (already in order due to loop structure)
    local fade_duration="0.4"
    local filter_complex=""
    local input_args=()
    
    # Build input arguments and filter complex
    for ((i=0; i<${#input_files[@]}; i++)); do
        input_args+=("-i" "${input_files[$i]}")
        
        local fade_filter=""
        local duration
        duration=$(get_video_duration "${input_files[$i]}")
        
        # Add fade-out to all except last
        if [[ $i -lt $((${#input_files[@]}-1)) ]]; then
            local fade_start
            fade_start=$(awk "BEGIN {v=$duration-$fade_duration; if (v>0) printf \"%.2f\", v; else print 0}")
            local fade_duration_actual
            fade_duration_actual=$(awk "BEGIN {v=$duration-$fade_start; if (v>0) printf \"%.2f\", v; else print $fade_duration}")
            fade_filter="fade=t=out:st=$fade_start:d=$fade_duration_actual"
        fi
        
        # Add fade-in to all except first
        if [[ $i -gt 0 ]]; then
            if [[ -n "$fade_filter" ]]; then
                fade_filter="$fade_filter,fade=t=in:st=0:d=$fade_duration"
            else
                fade_filter="fade=t=in:st=0:d=$fade_duration"
            fi
        fi
        
        # Add format and fade filters for video
        if [[ -n "$fade_filter" ]]; then
            filter_complex="$filter_complex[$i:v]format=yuv420p,$fade_filter[v$i];"
        else
            filter_complex="$filter_complex[$i:v]format=yuv420p[v$i];"
        fi
        
        # Add audio processing
        filter_complex="$filter_complex[$i:a]aformat=sample_rates=48000:channel_layouts=stereo[a$i];"
    done
    
    # Add concat filter for both video and audio
    for ((i=0; i<${#input_files[@]}; i++)); do
        filter_complex="$filter_complex[v$i][a$i]"
    done
    filter_complex="$filter_complex concat=n=${#input_files[@]}:v=1:a=1[outv][outa]"
    
    # Build FFmpeg command with QuickTime-compatible H.265 settings
    local ffmpeg_cmd=(
        ffmpeg -y -hwaccel videotoolbox
        "${input_args[@]}"
        -filter_complex "$filter_complex"
        -map "[outv]" -map "[outa]"
        -c:v hevc_videotoolbox
        -profile:v main10 -level 4.1
        -pix_fmt yuv420p10le
        -b:v "${BITRATE}k" -maxrate "${BITRATE}k" -bufsize "$((BITRATE * 2))k"
        -tag:v hvc1
        -movflags +faststart
        -c:a aac -b:a 163k
        "$output_file"
    )
    
    # Execute with quiet output for progress bar
    if "${ffmpeg_cmd[@]}" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Step 2: Join multiple files per presenter with integrated fade transitions
join_multiple_presenter_files() {
    log_info "=== Step 2: Joining multiple files per presenter ==="
    
    local multiple_presenters=()
    
    # Read multiple presenters list
    if [[ -f "${EXTRACTED_DIR}/.multiple_presenters" ]]; then
        while IFS= read -r -d '' presenter; do
            [[ -n "$presenter" ]] && multiple_presenters+=("$presenter")
        done < "${EXTRACTED_DIR}/.multiple_presenters"
    fi
    
    if [[ ${#multiple_presenters[@]} -eq 0 ]]; then
        log_info "No presenters with multiple files found"
        return 0
    fi
    
    # Initialize progress tracking for joining
    init_progress ${#multiple_presenters[@]}
    local completed_count=0
    local failed_joins=()
    
    for presenter in "${multiple_presenters[@]}"; do
        local first_file="${EXTRACTED_DIR}/${presenter}-1.mp4"
        local output_file="${EXTRACTED_DIR}/${presenter}-output.mp4"
        
        if [[ ! -f "$first_file" ]]; then
            ((completed_count++))
            update_progress "$completed_count"
            printf "\n${RED}[ERROR]${NC} First file not found for $presenter: $(safe_basename "$first_file")\n"
            failed_joins+=("$presenter")
            continue
        fi
        
        # Skip if output already exists and is newer than input files
        if [[ -f "$output_file" ]]; then
            local output_is_newer=true
            for i in {1..50}; do  # Check up to 50 segments
                local segment_file="${EXTRACTED_DIR}/${presenter}-${i}.mp4"
                [[ -f "$segment_file" && "$segment_file" -nt "$output_file" ]] && output_is_newer=false && break
            done
            
            if $output_is_newer; then
                ((completed_count++))
                update_progress "$completed_count"
                printf "\n${BLUE}[INFO]${NC} Skipping $presenter - output already exists and is newer\n"
                continue
            fi
        fi
        
        # Record start time for this presenter
        local join_start_time=$(date +%s)
        update_progress "$completed_count" "$presenter (joining segments)"
        show_file_progress "${presenter}-output.mp4"
        
        if join_video_files_with_fades "$presenter" "$output_file"; then
            ((completed_count++))
            update_progress "$completed_count" "" "$join_start_time"
            printf "\n${GREEN}[SUCCESS]${NC} Joined files for $presenter\n"
        else
            ((completed_count++))
            update_progress "$completed_count" "" "$join_start_time"
            printf "\n${RED}[ERROR]${NC} Failed to join files for $presenter\n"
            failed_joins+=("$presenter")
        fi
    done
    
    # Final progress update
    printf "\n"
    
    if [[ ${#failed_joins[@]} -gt 0 ]]; then
        log_error "Failed to join files for: ${failed_joins[*]}"
        exit 1
    fi
    
    log_success "All multiple-file presenters joined"
}

# Step 3: Re-compress joined files only if they're unexpectedly large
recompress_joined_files() {
    log_info "=== Step 3: Checking joined file sizes ==="
    
    local output_files=()
    local files_needing_compression=()
    
    # Find all *-output.mp4 files
    while IFS= read -r -d '' file; do
        output_files+=("$file")
    done < <(find "${EXTRACTED_DIR}" -name "*-output.mp4" -type f -print0)
    
    if [[ ${#output_files[@]} -eq 0 ]]; then
        log_info "No joined files found to check"
        return 0
    fi
    
    # Check each joined file to see if it needs recompression
    for output_file in "${output_files[@]}"; do
        local basename_file
        basename_file=$(safe_basename "$output_file" -output.mp4)
        
        # Calculate expected size by summing input segments
        local total_input_size=0
        local segment_count=0
        for i in {1..50}; do
            local segment_file="${EXTRACTED_DIR}/${basename_file}-${i}.mp4"
            if [[ -f "$segment_file" ]]; then
                local segment_size
                segment_size=$(stat -f%z "$segment_file" 2>/dev/null || echo "0")
                total_input_size=$((total_input_size + segment_size))
                ((segment_count++))
            fi
        done
        
        local output_size
        output_size=$(stat -f%z "$output_file" 2>/dev/null || echo "0")
        
        if [[ $total_input_size -gt 0 && $output_size -gt 0 ]]; then
            local size_ratio=$(( (output_size * 100) / total_input_size ))
            log_info "$(safe_basename "$output_file"): ${size_ratio}% of input segments size"
            
            # Only recompress if joined file is more than 150% of input size
            if [[ $size_ratio -gt 150 ]]; then
                log_warning "$(safe_basename "$output_file") is ${size_ratio}% of expected size - will recompress"
                files_needing_compression+=("$output_file")
            else
                log_success "$(safe_basename "$output_file") size is optimal (${size_ratio}% of input)"
            fi
        fi
    done
    
    if [[ ${#files_needing_compression[@]} -eq 0 ]]; then
        log_success "All joined files are optimally compressed - skipping Step 3"
        return 0
    fi
    
    log_info "Re-compressing ${#files_needing_compression[@]} oversized joined files..."
    local failed_recompressions=()
    
    for output_file in "${files_needing_compression[@]}"; do
        local basename_file
        basename_file=$(safe_basename "$output_file" -output.mp4)
        local compressed_file="${EXTRACTED_DIR}/${basename_file}-final.mp4"
        local temp_file="${EXTRACTED_DIR}/.${basename_file}-temp.mp4"
        
        log_info "Re-compressing $(safe_basename "$output_file")..."
        
        # Skip if final file already exists and is newer
        if [[ -f "$compressed_file" && "$compressed_file" -nt "$output_file" ]]; then
            log_info "Skipping $(safe_basename "$output_file") - final version already exists and is newer"
            continue
        fi
        
        # Use FFmpeg to compress the joined file with QuickTime compatibility
        local recompress_cmd=(
            ffmpeg -y -hwaccel videotoolbox
            -i "$output_file"
            -c:v hevc_videotoolbox
            -profile:v main10 -level 4.1
            -pix_fmt yuv420p10le
            -b:v "${BITRATE}k" -maxrate "${BITRATE}k" -bufsize "$((BITRATE * 2))k"
            -tag:v hvc1
            -movflags +faststart
            -af "$DYNAUDNORM_SETTINGS"
            -c:a aac -b:a 163k
            "$temp_file"
        )
        
        if "${recompress_cmd[@]}" 2>/dev/null; then
            
            # Verify the compressed file
            if [[ -f "$temp_file" && -s "$temp_file" ]]; then
                mv "$temp_file" "$compressed_file"
                
                # Calculate compression ratio
                local original_size compressed_size compression_ratio
                original_size=$(stat -f%z "$output_file" 2>/dev/null || echo "0")
                compressed_size=$(stat -f%z "$compressed_file" 2>/dev/null || echo "0")
                
                if [[ $original_size -gt 0 ]]; then
                    compression_ratio=$(( (compressed_size * 100) / original_size ))
                    log_success "Re-compressed $(safe_basename "$output_file") (${compression_ratio}% of original size)"
                else
                    log_success "Re-compressed $(safe_basename "$output_file")"
                fi
                
                # Replace the original output file with the compressed version
                mv "$compressed_file" "$output_file"
                log_info "Replaced $(safe_basename "$output_file") with compressed version"
            else
                log_error "Failed to create compressed file for $(safe_basename "$output_file")"
                [[ -f "$temp_file" ]] && rm "$temp_file"
                failed_recompressions+=("$(safe_basename "$output_file")")
            fi
        else
            log_error "HandBrake failed for $(safe_basename "$output_file")"
            [[ -f "$temp_file" ]] && rm "$temp_file"
            failed_recompressions+=("$(safe_basename "$output_file")")
        fi
    done
    
    if [[ ${#failed_recompressions[@]} -gt 0 ]]; then
        log_error "Failed to recompress: ${failed_recompressions[*]}"
        exit 1
    fi
    
    log_success "All joined files re-compressed"
}

# Generate final summary
generate_summary() {
    log_info "=== Processing Summary ==="
    
    local single_presenters=()
    local multiple_presenters=()
    
    # Read presenter lists
    if [[ -f "${EXTRACTED_DIR}/.single_presenters" ]]; then
        while IFS= read -r -d '' presenter; do
            [[ -n "$presenter" ]] && single_presenters+=("$presenter")
        done < "${EXTRACTED_DIR}/.single_presenters"
    fi
    
    if [[ -f "${EXTRACTED_DIR}/.multiple_presenters" ]]; then
        while IFS= read -r -d '' presenter; do
            [[ -n "$presenter" ]] && multiple_presenters+=("$presenter")
        done < "${EXTRACTED_DIR}/.multiple_presenters"
    fi
    
    log_info "Single segment files ready:"
    for presenter in "${single_presenters[@]:-}"; do
        local file="${EXTRACTED_DIR}/${presenter}-1.mp4"
        if [[ -f "$file" ]]; then
            local size
            size=$(du -h "$file" | cut -f1)
            log_info "  - $(safe_basename "$file") (${size})"
        fi
    done
    
    log_info "Multiple segment files joined and ready:"
    for presenter in "${multiple_presenters[@]}"; do
        local file="${EXTRACTED_DIR}/${presenter}-output.mp4"
        if [[ -f "$file" ]]; then
            local size
            size=$(du -h "$file" | cut -f1)
            log_info "  - $(safe_basename "$file") (${size})"
        fi
    done
    
    # Count total files ready for distribution
    local ready_files=0
    for presenter in "${single_presenters[@]:-}"; do
        [[ -f "${EXTRACTED_DIR}/${presenter}-1.mp4" ]] && ((ready_files++))
    done
    for presenter in "${multiple_presenters[@]}"; do
        [[ -f "${EXTRACTED_DIR}/${presenter}-output.mp4" ]] && ((ready_files++))
    done
    
    log_success "Processing complete! ${ready_files} files ready for distribution in ${EXTRACTED_DIR}"
    
    # Clean up temporary files
    rm -f "${EXTRACTED_DIR}/.single_presenters" "${EXTRACTED_DIR}/.multiple_presenters"
}

# Main execution
main() {
    log_info "SoundSplitter Video Post-Processing Script"
    log_info "=========================================="
    
    check_dependencies
    check_extracted_directory
    
    convert_all_mov_files
    analyze_presenters
    join_multiple_presenter_files
    recompress_joined_files
    generate_summary
    
    log_success "All processing completed successfully!"
}

# Handle script interruption
cleanup() {
    log_warning "Script interrupted. Cleaning up temporary files..."
    rm -f "${EXTRACTED_DIR}/.single_presenters" "${EXTRACTED_DIR}/.multiple_presenters"
    find "${EXTRACTED_DIR}" -name ".*-temp.mp4" -delete 2>/dev/null || true
    exit 130
}

# Set up signal handlers
trap cleanup INT TERM

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi